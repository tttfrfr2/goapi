/*
Future Vuls Public API

Future Vuls Public API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TaskApiService TaskApi service
type TaskApiService service

type ApiTaskAddTaskCommentRequest struct {
	ctx context.Context
	ApiService *TaskApiService
	taskID int64
	addTaskCommentRequestBody *TaskAddTaskCommentRequestBody
	authorization *string
}

func (r ApiTaskAddTaskCommentRequest) AddTaskCommentRequestBody(addTaskCommentRequestBody TaskAddTaskCommentRequestBody) ApiTaskAddTaskCommentRequest {
	r.addTaskCommentRequestBody = &addTaskCommentRequestBody
	return r
}

// api key auth
func (r ApiTaskAddTaskCommentRequest) Authorization(authorization string) ApiTaskAddTaskCommentRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTaskAddTaskCommentRequest) Execute() (*TaskAddTaskCommentResponseBody, *http.Response, error) {
	return r.ApiService.TaskAddTaskCommentExecute(r)
}

/*
TaskAddTaskComment addTaskComment task

add task comment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskID Task ID
 @return ApiTaskAddTaskCommentRequest
*/
func (a *TaskApiService) TaskAddTaskComment(ctx context.Context, taskID int64) ApiTaskAddTaskCommentRequest {
	return ApiTaskAddTaskCommentRequest{
		ApiService: a,
		ctx: ctx,
		taskID: taskID,
	}
}

// Execute executes the request
//  @return TaskAddTaskCommentResponseBody
func (a *TaskApiService) TaskAddTaskCommentExecute(r ApiTaskAddTaskCommentRequest) (*TaskAddTaskCommentResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskAddTaskCommentResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.TaskAddTaskComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/task/{taskID}/comment"
	localVarPath = strings.Replace(localVarPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addTaskCommentRequestBody == nil {
		return localVarReturnValue, nil, reportError("addTaskCommentRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "application/gob"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "application/gob"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	// body params
	localVarPostBody = r.addTaskCommentRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskGetTaskDetailRequest struct {
	ctx context.Context
	ApiService *TaskApiService
	taskID int64
	authorization *string
}

// api key auth
func (r ApiTaskGetTaskDetailRequest) Authorization(authorization string) ApiTaskGetTaskDetailRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTaskGetTaskDetailRequest) Execute() (*TaskGetTaskDetailResponseBody, *http.Response, error) {
	return r.ApiService.TaskGetTaskDetailExecute(r)
}

/*
TaskGetTaskDetail getTaskDetail task

task detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskID Task ID
 @return ApiTaskGetTaskDetailRequest
*/
func (a *TaskApiService) TaskGetTaskDetail(ctx context.Context, taskID int64) ApiTaskGetTaskDetailRequest {
	return ApiTaskGetTaskDetailRequest{
		ApiService: a,
		ctx: ctx,
		taskID: taskID,
	}
}

// Execute executes the request
//  @return TaskGetTaskDetailResponseBody
func (a *TaskApiService) TaskGetTaskDetailExecute(r ApiTaskGetTaskDetailRequest) (*TaskGetTaskDetailResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskGetTaskDetailResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.TaskGetTaskDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/task/{taskID}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "application/gob"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskGetTaskListRequest struct {
	ctx context.Context
	ApiService *TaskApiService
	page *int32
	limit *int32
	offset *int32
	filterStatus *[]string
	filterPriority *[]string
	filterIgnore *bool
	filterMainUserIDs *[]int32
	filterSubUserIDs *[]int32
	filterCveID *string
	filterServerID *int32
	filterRoleID *int32
	filterPkgID *int32
	filterCpeID *int32
	authorization *string
}

// Page Number
func (r ApiTaskGetTaskListRequest) Page(page int32) ApiTaskGetTaskListRequest {
	r.page = &page
	return r
}

// Limit
func (r ApiTaskGetTaskListRequest) Limit(limit int32) ApiTaskGetTaskListRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiTaskGetTaskListRequest) Offset(offset int32) ApiTaskGetTaskListRequest {
	r.offset = &offset
	return r
}

// Status filter
func (r ApiTaskGetTaskListRequest) FilterStatus(filterStatus []string) ApiTaskGetTaskListRequest {
	r.filterStatus = &filterStatus
	return r
}

// Priority filter
func (r ApiTaskGetTaskListRequest) FilterPriority(filterPriority []string) ApiTaskGetTaskListRequest {
	r.filterPriority = &filterPriority
	return r
}

// Ignore filter(trueの場合は、非表示のものを取得しない。falseの場合は全件取得)
func (r ApiTaskGetTaskListRequest) FilterIgnore(filterIgnore bool) ApiTaskGetTaskListRequest {
	r.filterIgnore = &filterIgnore
	return r
}

// MainUserIDs filter
func (r ApiTaskGetTaskListRequest) FilterMainUserIDs(filterMainUserIDs []int32) ApiTaskGetTaskListRequest {
	r.filterMainUserIDs = &filterMainUserIDs
	return r
}

// SubUserIDs filter
func (r ApiTaskGetTaskListRequest) FilterSubUserIDs(filterSubUserIDs []int32) ApiTaskGetTaskListRequest {
	r.filterSubUserIDs = &filterSubUserIDs
	return r
}

// CveID filter
func (r ApiTaskGetTaskListRequest) FilterCveID(filterCveID string) ApiTaskGetTaskListRequest {
	r.filterCveID = &filterCveID
	return r
}

// ServerID filter
func (r ApiTaskGetTaskListRequest) FilterServerID(filterServerID int32) ApiTaskGetTaskListRequest {
	r.filterServerID = &filterServerID
	return r
}

// ServerRoleID filter
func (r ApiTaskGetTaskListRequest) FilterRoleID(filterRoleID int32) ApiTaskGetTaskListRequest {
	r.filterRoleID = &filterRoleID
	return r
}

// PackageID filter
func (r ApiTaskGetTaskListRequest) FilterPkgID(filterPkgID int32) ApiTaskGetTaskListRequest {
	r.filterPkgID = &filterPkgID
	return r
}

// CpeID filter
func (r ApiTaskGetTaskListRequest) FilterCpeID(filterCpeID int32) ApiTaskGetTaskListRequest {
	r.filterCpeID = &filterCpeID
	return r
}

// api key auth
func (r ApiTaskGetTaskListRequest) Authorization(authorization string) ApiTaskGetTaskListRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTaskGetTaskListRequest) Execute() (*TaskGetTaskListResponseBody, *http.Response, error) {
	return r.ApiService.TaskGetTaskListExecute(r)
}

/*
TaskGetTaskList getTaskList task

task list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaskGetTaskListRequest
*/
func (a *TaskApiService) TaskGetTaskList(ctx context.Context) ApiTaskGetTaskListRequest {
	return ApiTaskGetTaskListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskGetTaskListResponseBody
func (a *TaskApiService) TaskGetTaskListExecute(r ApiTaskGetTaskListRequest) (*TaskGetTaskListResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskGetTaskListResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.TaskGetTaskList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filterStatus", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filterStatus", parameterToString(t, "multi"))
		}
	}
	if r.filterPriority != nil {
		t := *r.filterPriority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filterPriority", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filterPriority", parameterToString(t, "multi"))
		}
	}
	if r.filterIgnore != nil {
		localVarQueryParams.Add("filterIgnore", parameterToString(*r.filterIgnore, ""))
	}
	if r.filterMainUserIDs != nil {
		t := *r.filterMainUserIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filterMainUserIDs", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filterMainUserIDs", parameterToString(t, "multi"))
		}
	}
	if r.filterSubUserIDs != nil {
		t := *r.filterSubUserIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filterSubUserIDs", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filterSubUserIDs", parameterToString(t, "multi"))
		}
	}
	if r.filterCveID != nil {
		localVarQueryParams.Add("filterCveID", parameterToString(*r.filterCveID, ""))
	}
	if r.filterServerID != nil {
		localVarQueryParams.Add("filterServerID", parameterToString(*r.filterServerID, ""))
	}
	if r.filterRoleID != nil {
		localVarQueryParams.Add("filterRoleID", parameterToString(*r.filterRoleID, ""))
	}
	if r.filterPkgID != nil {
		localVarQueryParams.Add("filterPkgID", parameterToString(*r.filterPkgID, ""))
	}
	if r.filterCpeID != nil {
		localVarQueryParams.Add("filterCpeID", parameterToString(*r.filterCpeID, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "application/gob"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskUpdateTaskRequest struct {
	ctx context.Context
	ApiService *TaskApiService
	taskID int64
	updateTaskRequestBody *TaskUpdateTaskRequestBody
	authorization *string
}

func (r ApiTaskUpdateTaskRequest) UpdateTaskRequestBody(updateTaskRequestBody TaskUpdateTaskRequestBody) ApiTaskUpdateTaskRequest {
	r.updateTaskRequestBody = &updateTaskRequestBody
	return r
}

// api key auth
func (r ApiTaskUpdateTaskRequest) Authorization(authorization string) ApiTaskUpdateTaskRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTaskUpdateTaskRequest) Execute() (*TaskUpdateTaskResponseBody, *http.Response, error) {
	return r.ApiService.TaskUpdateTaskExecute(r)
}

/*
TaskUpdateTask updateTask task

update task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskID Task ID
 @return ApiTaskUpdateTaskRequest
*/
func (a *TaskApiService) TaskUpdateTask(ctx context.Context, taskID int64) ApiTaskUpdateTaskRequest {
	return ApiTaskUpdateTaskRequest{
		ApiService: a,
		ctx: ctx,
		taskID: taskID,
	}
}

// Execute executes the request
//  @return TaskUpdateTaskResponseBody
func (a *TaskApiService) TaskUpdateTaskExecute(r ApiTaskUpdateTaskRequest) (*TaskUpdateTaskResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskUpdateTaskResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.TaskUpdateTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/task/{taskID}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTaskRequestBody == nil {
		return localVarReturnValue, nil, reportError("updateTaskRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "application/gob"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "application/gob"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	// body params
	localVarPostBody = r.updateTaskRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskUpdateTaskIgnoreRequest struct {
	ctx context.Context
	ApiService *TaskApiService
	taskID int64
	updateTaskIgnoreRequestBody *TaskUpdateTaskIgnoreRequestBody
	authorization *string
}

func (r ApiTaskUpdateTaskIgnoreRequest) UpdateTaskIgnoreRequestBody(updateTaskIgnoreRequestBody TaskUpdateTaskIgnoreRequestBody) ApiTaskUpdateTaskIgnoreRequest {
	r.updateTaskIgnoreRequestBody = &updateTaskIgnoreRequestBody
	return r
}

// api key auth
func (r ApiTaskUpdateTaskIgnoreRequest) Authorization(authorization string) ApiTaskUpdateTaskIgnoreRequest {
	r.authorization = &authorization
	return r
}

func (r ApiTaskUpdateTaskIgnoreRequest) Execute() (*TaskUpdateTaskIgnoreResponseBody, *http.Response, error) {
	return r.ApiService.TaskUpdateTaskIgnoreExecute(r)
}

/*
TaskUpdateTaskIgnore updateTaskIgnore task

update task ignore

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskID Task ID
 @return ApiTaskUpdateTaskIgnoreRequest
*/
func (a *TaskApiService) TaskUpdateTaskIgnore(ctx context.Context, taskID int64) ApiTaskUpdateTaskIgnoreRequest {
	return ApiTaskUpdateTaskIgnoreRequest{
		ApiService: a,
		ctx: ctx,
		taskID: taskID,
	}
}

// Execute executes the request
//  @return TaskUpdateTaskIgnoreResponseBody
func (a *TaskApiService) TaskUpdateTaskIgnoreExecute(r ApiTaskUpdateTaskIgnoreRequest) (*TaskUpdateTaskIgnoreResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskUpdateTaskIgnoreResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.TaskUpdateTaskIgnore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/task/{taskID}/ignore"
	localVarPath = strings.Replace(localVarPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTaskIgnoreRequestBody == nil {
		return localVarReturnValue, nil, reportError("updateTaskIgnoreRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "application/gob"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml", "application/gob"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	}
	// body params
	localVarPostBody = r.updateTaskIgnoreRequestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_header_Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
